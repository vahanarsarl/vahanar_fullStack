#!/bin/bash

# Red Hat Node.js PostgreSQL Deployment Script
# This script automates the deployment of a Node.js application with PostgreSQL on Red Hat Linux.

# Exit immediately if a command exits with a non-zero status
set -e

# Configuration variables - MODIFY THESE
APP_NAME="backend"
GIT_REPO="your-repo-url"
DB_USER="your_username"
DB_PASSWORD="your_password"
DB_NAME="your_db_name"
DOMAIN="your_domain_or_ip"
NODE_ENV="production"
PORT="3000"
ADMIN_EMAIL="your-email@example.com"

# Colors for output
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Helper function for section headers
section() {
  echo -e "${YELLOW}\n==== $1 ====${NC}"
}

# Helper function for success messages
success() {
  echo -e "${GREEN}✓ $1${NC}"
}

# Helper function for error messages
error() {
  echo -e "${RED}✗ $1${NC}"
  exit 1
}

# Check if running as root
if [ "$EUID" -ne 0 ]; then
  error "Please run as root or with sudo"
fi

# 1. Install Node.js and npm
section "Installing Node.js and npm"
dnf install -y nodejs npm
success "Node.js and npm installed"

# 2. Install PostgreSQL
section "Installing PostgreSQL"
dnf install -y postgresql postgresql-server
postgresql-setup --initdb
systemctl enable postgresql
systemctl start postgresql
success "PostgreSQL installed and started"

# 3. Create PostgreSQL user and database
section "Setting up PostgreSQL database"
cat > /tmp/db_setup.sql << EOF
CREATE USER ${DB_USER} WITH PASSWORD '${DB_PASSWORD}';
CREATE DATABASE ${DB_NAME};
GRANT ALL PRIVILEGES ON DATABASE ${DB_NAME} TO ${DB_USER};
EOF

su - postgres -c "psql -f /tmp/db_setup.sql"
rm /tmp/db_setup.sql
success "PostgreSQL user and database created"

# 4. Clone repository
section "Cloning application repository"
if [ -d "${APP_NAME}" ]; then
  echo "Directory ${APP_NAME} already exists, updating instead of cloning"
  cd ${APP_NAME}
  git pull
  cd ..
else
  git clone ${GIT_REPO} ${APP_NAME}
fi
success "Repository cloned/updated"

# 5. Install dependencies
section "Installing application dependencies"
cd ${APP_NAME}
npm install
success "Dependencies installed"

# 6. Set up environment variables
section "Setting up environment variables"
if [ ! -f .env.example ]; then
  echo "Warning: .env.example not found, creating a basic .env file"
  cat > .env << EOF
NODE_ENV=${NODE_ENV}
PORT=${PORT}
DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5432/${DB_NAME}
EOF
else
  cp .env.example .env
  # Update database connection string in .env
  sed -i "s|DATABASE_URL=.*|DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5432/${DB_NAME}|g" .env
  sed -i "s|PORT=.*|PORT=${PORT}|g" .env
  sed -i "s|NODE_ENV=.*|NODE_ENV=${NODE_ENV}|g" .env
fi
success "Environment variables configured"

# 7. Generate Prisma client and run migrations
section "Setting up database with Prisma"
if [ -d "node_modules/.prisma" ]; then
  npx prisma generate
  npx prisma migrate deploy
  # Optional: Seed the database
  if [ -f "prisma/seed.ts" ] || [ -f "prisma/seed.js" ]; then
    npm run seed || echo "Seed script failed but continuing deployment"
  fi
  success "Prisma setup completed"
else
  echo "Prisma not detected, skipping this step"
fi

# 8. Build the application
section "Building the application"
npm run build
success "Application built"

# 9. Install and configure PM2
section "Setting up PM2 process manager"
npm install -g pm2
pm2 start npm --name "${APP_NAME}" -- start
pm2 save

# Set up PM2 to start on boot
pm2_startup=$(pm2 startup | grep -v '[PM2]' | tail -n 1)
eval ${pm2_startup}
success "PM2 configured"

# 10. Install and configure Nginx
section "Setting up Nginx reverse proxy"
dnf install -y nginx
systemctl enable nginx
systemctl start nginx

# Create Nginx configuration
cat > /etc/nginx/conf.d/${APP_NAME}.conf << EOF
server {
    listen 80;
    server_name ${DOMAIN};

    location / {
        proxy_pass http://localhost:${PORT};
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_cache_bypass \$http_upgrade;
    }
}
EOF

# Test Nginx configuration
nginx -t
systemctl reload nginx
success "Nginx configured"

# 11. Set up firewall
section "Configuring firewall"
dnf install -y firewalld
systemctl enable firewalld
systemctl start firewalld

# Allow HTTP, HTTPS, and SSH traffic
firewall-cmd --permanent --add-service=http
firewall-cmd --permanent --add-service=https
firewall-cmd --permanent --add-service=ssh
firewall-cmd --reload
success "Firewall configured"

# 12. Set up SSL with Let's Encrypt (if domain provided)
if [[ ${DOMAIN} != *"."* ]]; then
  echo "Skipping SSL setup as domain appears to be an IP address"
else
  section "Setting up SSL with Let's Encrypt"
  dnf install -y epel-release
  dnf install -y certbot python3-certbot-nginx
  
  # Attempt to obtain SSL certificate
  certbot --nginx -d ${DOMAIN} --non-interactive --agree-tos --email ${ADMIN_EMAIL} || echo "SSL setup failed, you can manually run: certbot --nginx -d ${DOMAIN}"
  
  # Set up auto-renewal
  systemctl enable certbot-renew.timer
  systemctl start certbot-renew.timer
  success "SSL configured"
fi

# 13. Set up database backups
section "Setting up database backups"
cat > /usr/local/bin/backup-db.sh << EOF
#!/bin/bash
BACKUP_DIR="/var/backups/postgres"
TIMESTAMP=\$(date +"%Y%m%d_%H%M%S")
mkdir -p \$BACKUP_DIR
sudo -u postgres pg_dump ${DB_NAME} > \$BACKUP_DIR/${DB_NAME}_\$TIMESTAMP.sql
find \$BACKUP_DIR -type f -mtime +7 -name "*.sql" -delete
EOF

chmod +x /usr/local/bin/backup-db.sh
(crontab -l 2>/dev/null; echo "0 2 * * * /usr/local/bin/backup-db.sh") | crontab -
success "Database backups configured"

# 14. Set up system monitoring
section "Installing system monitoring tools"
dnf install -y htop iotop sysstat
systemctl enable sysstat
systemctl start sysstat
success "System monitoring tools installed"

# 15. Additional security hardening
section "Applying security hardening"
# Disable root SSH login
sed -i 's/^#\?PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config
systemctl restart sshd
success "SSH hardened"

# 16. Regular system updates
section "Setting up automatic system updates"
cat > /usr/local/bin/update-system.sh << EOF
#!/bin/bash
dnf -y update
npm update -g
EOF

chmod +x /usr/local/bin/update-system.sh
(crontab -l 2>/dev/null; echo "0 3 * * 0 /usr/local/bin/update-system.sh") | crontab -
success "Automatic updates configured"

# 17. Set up application health check
section "Setting up application health checks"
cat > /usr/local/bin/health-check.sh << EOF
#!/bin/bash
response=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${PORT}/health)
if [ \$response -ne 200 ]; then
  pm2 restart ${APP_NAME}
  echo "Application restarted due to health check failure" | mail -s "App Health Alert" ${ADMIN_EMAIL}
fi
EOF

chmod +x /usr/local/bin/health-check.sh
(crontab -l 2>/dev/null; echo "*/5 * * * * /usr/local/bin/health-check.sh") | crontab -
success "Health checks configured"

# 18. Set up logrotate for PM2 logs
section "Setting up log rotation"
cat > /etc/logrotate.d/pm2 << EOF
/root/.pm2/logs/*.log {
  daily
  rotate 7
  compress
  delaycompress
  missingok
  notifempty
  create 0640 root root
}
EOF
success "Log rotation configured"

section "Deployment Complete"
echo "Your Node.js application has been deployed and configured."
echo "Application URL: http://${DOMAIN}"
echo "Database: ${DB_NAME}"
echo "PM2 process name: ${APP_NAME}"

echo -e "\nUseful commands:"
echo "- View app logs: pm2 logs ${APP_NAME}"
echo "- Monitor app: pm2 monit"
echo "- Restart app: pm2 restart ${APP_NAME}"
echo "- Test Nginx: curl http://localhost"
echo "- View firewall status: firewall-cmd --list-all"

exit 0